Index: Backend/Bauernschach_Spiel.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import pygame, sys, uuid, pygame_gui\r\n\r\nfrom math import inf\r\nfrom anytree import Node, RenderTree\r\nfrom classes.button import Button\r\nfrom tkinter import messagebox\r\nfrom queries.postFinishedGame import postFinishedGameQuery\r\n\r\n\r\n\r\npygame.init()\r\n\r\nclass Position:\r\n\r\n    gameover = False\r\n\r\n    def __init__(self, color, x, y):\r\n        self.color = color\r\n        self.x = x\r\n        self.y = y\r\n\r\n    def fillChildren(self):\r\n        return\r\n    def refreshChildren(self):\r\n        return\r\n\r\n\r\nclass Pawn:\r\n\r\n    currentTurn = \"white\"\r\n\r\n    def __init__(self, color, x, y):\r\n        self.color = color\r\n        self.x = x\r\n        self.y = y\r\n        self.has_moved = False  # Variable, welche angibt, ob der Bauer sich bewegt hat\r\n        self.has_beaten = False  # Variable die angibt, ob geschlagen wurde\r\n\r\n    def draw(self, surface, selected=False):\r\n        radius = 30\r\n        if self.color == \"white\":\r\n            if selected:\r\n                color = (0, 255, 0)  # green if selected\r\n            else:\r\n                color = (255, 255, 255)\r\n        else:\r\n            if selected:\r\n                color = (0, 255, 0)  # green if selected\r\n            else:\r\n                color = (0, 0, 0)\r\n        pygame.draw.circle(surface, color, (self.x * 80 + 40, self.y * 80 + 40), radius)\r\n\r\n# render the board and pawns\r\ndef reRender(sizeX, sizeY, screen):\r\n    board.fill((255, 206, 158))\r\n    for x in range(0, 6, 2):\r\n        for y in range(0, 6, 2):\r\n            rect1 = pygame.draw.rect(board, (210, 180, 140), (x * 80, y * 80, 80, 80))\r\n            rect2 = pygame.draw.rect(board, (210, 180, 140), ((x + 1) * 80, (y + 1) * 80, 80, 80))\r\n\r\n    for pawn in pawns:\r\n        pawn.draw(board, selected=(pawn == selected_pawn))\r\n\r\n        # add the board to the screen\r\n    screen.blit(board, ((sizeX/2)-(480/2), (sizeY/2)-(480/2)))\r\n    pygame.display.flip()\r\n\r\n#defining font size and get font element\r\ndef font(size): \r\n    return pygame.font.Font(\"resources/mainFont.ttf\", size)\r\n\r\n# set up the pawns\r\npawns = []\r\nfor i in range(6):\r\n    pawns.append(Pawn(\"black\", i, 0))\r\n    pawns.append(Pawn(\"white\", i, 5))\r\nselected_pawn = None\r\n\r\n# set up the board\r\nsquares = []\r\nboard = pygame.Surface((480, 480))\r\nboard.fill((255, 206, 158))\r\nfor x in range(0, 6, 2):\r\n    for y in range(0, 6, 2):\r\n        rect1 = pygame.draw.rect(board, (210, 180, 140), (x * 80, y * 80, 80, 80))\r\n        rect2 = pygame.draw.rect(board, (210, 180, 140), ((x + 1) * 80, (y + 1) * 80, 80, 80))\r\n        squares.append(rect1)\r\n        squares.append(rect2)\r\n\r\nprint(squares)\r\n\r\nfor pawn in pawns:\r\n    pawn.draw(board, selected=False)  # pass selected flag\r\n    # add the board to the screen\r\n\r\n#Minimax Algorithmus mit Alpha-Beta-Pruning\r\ndef minimax(position, depth, alpha, beta, maximizing_player):\r\n    if depth == 0 or position.gameover:\r\n        return position.evaluation\r\n\r\n    if maximizing_player is True:\r\n        max_eval = float(-inf)\r\n        for child in position:\r\n            eval = minimax(child, depth - 1, alpha, beta, False)\r\n            max_eval = max(max_eval, eval)\r\n            alpha = max(alpha, eval)\r\n            if beta <= alpha:\r\n                break\r\n        return max_eval\r\n    else:\r\n        min_eval = float(inf)\r\n        for child in position:\r\n            eval = minimax(child, depth - 1, alpha, beta, True)\r\n            min_eval = min(min_eval, eval)\r\n            beta = min(beta, eval)\r\n            if beta <= alpha:\r\n                break\r\n        return min_eval\r\n\r\ndef chessGame(sizeX,sizeY,screen, userName, difficulty):\r\n    global selected_pawn, beaten_pawn, pawn_to_beat, last_pos\r\n    current_turn = \"white\"\r\n    run = True\r\n    last_pos = None\r\n    unique_ID = f\"{uuid.uuid4()}\"\r\n    print(type(unique_ID))\r\n  \r\n    screen.fill(\"black\")\r\n    global selected_pawn\r\n    screen.blit(board, ((sizeX/2)-(480/2), (sizeY/2)-(480/2)))\r\n    \r\n\r\n    backgroundIMG = pygame.image.load(\"resources/envi.jpg\")\r\n    background = pygame.transform.scale(backgroundIMG,(sizeX, sizeY))\r\n\r\n    screen.blit(background, (0, 0))\r\n\r\n    reRender(sizeX, sizeY, screen)\r\n\r\n    # the game\r\n    while run is True:\r\n        \r\n        MENU_MOUSE_POS = pygame.mouse.get_pos()\r\n        showHelp = Button(image=pygame.image.load(\"resources/test.png\"), pos=(sizeX-100, sizeY-50), \r\n                            text_input=\"Regeln\", font=font(30), base_color=\"#d7fcd4\", hovering_color=\"Yellow\")\r\n        \r\n        for button in [showHelp]:\r\n            button.changeColor(MENU_MOUSE_POS)\r\n            button.update(screen)\r\n            reRender(sizeX, sizeY, screen)\r\n\r\n        for event in pygame.event.get():\r\n            if event.type == pygame.QUIT:\r\n                pygame.quit()\r\n                sys.exit()\r\n            if event.type == pygame.MOUSEBUTTONDOWN:\r\n                if showHelp.checkForInput(MENU_MOUSE_POS):\r\n                    \r\n                    messagebox.showinfo(\"\"\"\r\n                    Es gibt zwei erlaubte Sorten von Zügen :\r\n                    1)\tZiehen\r\n                    kann ein Bauer, indem er ein Feld in Richtung der gegnerischen Grundlinie (das sind die Felder, auf denen anfangs die gegnerischen Bauern stehen) geht, aber nur sofern dieses Feld frei ist (also nicht von einem eigenen oder gegnerischen Bauern besetzt ist). \r\n                    2)\tSchlagen\r\n                    kann ein Bauer in Richtung der gegnerischen Grundlinie durch diagonales Ziehen in Richtung der gegnerischen Grundlinie, aber nur auf ein Feld, auf dem ein gegnerischer Bauer steht. \r\n                    \"\"\", \"\"\"Bauernschach\r\n                    ist eine simple Variante des Schachs, die nur mit Bauern gespielt wird. In der Ausgansstellung stehen dabei die weißen bzw. schwarzen Spielfiguren (Bauern) auf der jeweiligen Grundlinie. Die Spieler machen abwechselnd einen Zug, wobei Weiß beginnt. \r\n\r\n                    Für den Prototypen soll immer der menschliche Spieler beginnen und die KI entsprechend mit den schwarzen Spielfiguren ziehen. \r\n\r\n                    Es gibt zwei erlaubte Sorten von Zügen :\r\n                    1)\tZiehen\r\n                    kann ein Bauer, indem er ein Feld in Richtung der gegnerischen Grundlinie (das sind die Felder, auf denen anfangs die gegnerischen Bauern stehen) geht, aber nur sofern dieses Feld frei ist (also nicht von einem eigenen oder gegnerischen Bauern besetzt ist). \r\n                    2)\tSchlagen\r\n                    kann ein Bauer in Richtung der gegnerischen Grundlinie durch diagonales Ziehen in Richtung der gegnerischen Grundlinie, aber nur auf ein Feld, auf dem ein gegnerischer Bauer steht. \r\n\r\n                    Ziel des Spieles ist es, einen Bauern auf die generische Grundlinie zu platzieren; wenn das gelingt, ist das Spiel sofort zu Ende und die Farbe, die das erreicht hat, hat gewonnen. Wenn ein Spieler nicht mehr ziehen kann, oder überhaupt keine Figuren mehr hat, ist das Spiel für ihn als verloren zu werten. Ein unentschieden ist daher in dieser Variante nicht möglich.\r\n                    \"\"\")\r\n                \r\n            if event.type == pygame.MOUSEBUTTONDOWN:\r\n                # Speichert die Position des Mouseklicks in der Variable pos\r\n                pos = pygame.mouse.get_pos()\r\n\r\n                # Konvertiert die Positionen in Boardkoordinaten\r\n                x = (pos[0] - (int)((sizeX/2)-(480/2))) // 80\r\n                y = (pos[1] - (int)((sizeY/2)-(480/2))) // 80\r\n\r\n                if selected_pawn is None or (selected_pawn is not None and selected_pawn.color is not current_turn):\r\n                    # Prüft, ob ein Bauer angeklickt wurde\r\n                    for pawn in pawns:\r\n                        if pawn.x == x and pawn.y == y:\r\n                            selected_pawn = pawn\r\n\r\n                            print(pawn)\r\n                            break\r\n\r\n\r\n                    # Prüft, ob ein Bauer angeklickt wurde\r\n                    for pawn in pawns:\r\n                        if pawn.x == x and pawn.y == y:\r\n                            selected_pawn = pawn\r\n\r\n                            print(pawn)\r\n                            break\r\n                    last_pos = pos\r\n            elif event.type == pygame.MOUSEBUTTONUP and selected_pawn is not None and selected_pawn.color is \\\r\n                    current_turn:\r\n                # Speichert die Position des Mouseklicks\r\n                pos = pygame.mouse.get_pos()\r\n\r\n                # Konvertiert die Positionen in Boardkoordinaten\r\n                x = (pos[0] - (int)((sizeX/2)-(480/2))) // 80\r\n                y = (pos[1] - (int)((sizeY/2)-(480/2))) // 80\r\n\r\n                for pawn in pawns:\r\n                    beaten_pawn = False\r\n                    if pawn.x == x and pawn.y == y and pawn.color is not selected_pawn.color:\r\n                        pawn_to_beat = pawn\r\n                        beaten_pawn = True\r\n                        break\r\n\r\n                # Spielfigur bewegen, wenn der Spielzug gültig ist\r\n                if selected_pawn.color == \"white\" and selected_pawn.color == current_turn:\r\n                    if selected_pawn.y == 5 and y == 3 and x == selected_pawn.x and beaten_pawn is False:\r\n                        # Möglichkeit beim ersten Spielzug zwei Felder zu bewegen\r\n                        selected_pawn.x = x\r\n                        selected_pawn.y = y\r\n                        current_turn = \"black\"\r\n                    elif y == selected_pawn.y - 1 and x == selected_pawn.x and beaten_pawn is False:\r\n                        # Ein Spielfeld nach vorne bewegen\r\n                        selected_pawn.x = x\r\n                        selected_pawn.y = y\r\n                        current_turn = \"black\"\r\n                    elif y == selected_pawn.y - 1 and x == selected_pawn.x - 1 and beaten_pawn is True:\r\n                        selected_pawn.x = x\r\n                        selected_pawn.y = y\r\n                        current_turn = \"black\"\r\n                        pawns.remove(pawn_to_beat)\r\n                    elif y == selected_pawn.y - 1 and x == selected_pawn.x + 1 and beaten_pawn is True:\r\n                        selected_pawn.x = x\r\n                        selected_pawn.y = y\r\n                        current_turn = \"black\"\r\n                        pawns.remove(pawn_to_beat)\r\n                elif selected_pawn.color == \"black\" and selected_pawn.color == current_turn:\r\n                    if selected_pawn.y == 0 and y == 2 and x == selected_pawn.x and beaten_pawn is False:\r\n                        # Möglichkeit beim ersten Spielzug zwei Felder zu bewegen\r\n                        selected_pawn.x = x\r\n                        selected_pawn.y = y\r\n                        current_turn = \"white\"\r\n                    elif y == selected_pawn.y + 1 and x == selected_pawn.x and beaten_pawn is False:\r\n                        # Ein Spielfeld nach vorne bewegen\r\n                        selected_pawn.x = x\r\n                        selected_pawn.y = y\r\n                        current_turn = \"white\"\r\n                    elif y == selected_pawn.y + 1 and x == selected_pawn.x - 1 and beaten_pawn is True:\r\n                        selected_pawn.x = x\r\n                        selected_pawn.y = y\r\n                        current_turn = \"white\"\r\n                        pawns.remove(pawn_to_beat)\r\n                    elif y == selected_pawn.y + 1 and x == selected_pawn.x + 1 and beaten_pawn is True:\r\n                        selected_pawn.x = x\r\n                        selected_pawn.y = y\r\n                        current_turn = \"white\"\r\n                        pawns.remove(pawn_to_beat)\r\n                if selected_pawn.color == \"white\" and selected_pawn.y == 0:\r\n                    run = False\r\n                    print(\"Weiß hat gewonnen\")\r\n                    print(f\"{unique_ID}, {userName}, turns, {difficulty}, {0}\")\r\n                    postFinishedGameQuery(unique_ID, userName, 15, 2, False)\r\n                    \r\n\r\n                elif selected_pawn.color == \"black\" and selected_pawn.y == 5:\r\n                    run = False\r\n                    print(\"Schwarz hat gewonnen\")\r\n                    print(f\"{unique_ID}, {userName}, turns, {difficulty}, {1}\")\r\n                    postFinishedGameQuery(unique_ID, userName, 11, 2, True)\r\n\r\n                reRender(sizeX, sizeY, screen)\r\n\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Backend/Bauernschach_Spiel.py b/Backend/Bauernschach_Spiel.py
--- a/Backend/Bauernschach_Spiel.py	(revision 46b76cb67b45b818d6408c1a503c2d227b91239d)
+++ b/Backend/Bauernschach_Spiel.py	(date 1681917089382)
@@ -1,34 +1,23 @@
-import pygame, sys, uuid, pygame_gui
-
 from math import inf
 from anytree import Node, RenderTree
-from classes.button import Button
-from tkinter import messagebox
-from queries.postFinishedGame import postFinishedGameQuery
 
+import pygame
+import sys
 
+import pygame_gui
 
 pygame.init()
 
-class Position:
-
-    gameover = False
-
-    def __init__(self, color, x, y):
-        self.color = color
-        self.x = x
-        self.y = y
-
-    def fillChildren(self):
-        return
-    def refreshChildren(self):
-        return
-
+# Setzt die Spielfelder
+boardArray = [["b", "b", "b", "b", "b", "b"],
+         [" ", " ", " ", " ", " ", " "],
+         [" ", " ", " ", " ", " ", " "],
+         [" ", " ", " ", " ", " ", " "],
+         [" ", " ", " ", " ", " ", " "],
+         ["w", "w", "w", "w", "w", "w"]]
 
 class Pawn:
 
-    currentTurn = "white"
-
     def __init__(self, color, x, y):
         self.color = color
         self.x = x
@@ -65,9 +54,6 @@
     screen.blit(board, ((sizeX/2)-(480/2), (sizeY/2)-(480/2)))
     pygame.display.flip()
 
-#defining font size and get font element
-def font(size): 
-    return pygame.font.Font("resources/mainFont.ttf", size)
 
 # set up the pawns
 pawns = []
@@ -116,163 +102,240 @@
             if beta <= alpha:
                 break
         return min_eval
+def searchPawn(y, x):
+    # Prüft, ob ein Bauer angeklickt wurde
+    for pawn in pawns:
+        if pawn.x == x and pawn.y == y:
+            return pawn
+
+def getBestMove(x, y, boardArray):
+    if y >= 2:
+        if x < 2 or x > 3:
+            if x > 0 and boardArray[y + 1][x - 1] == "w":
+                return [x, y, x - 1, y + 1, 5]
+            if x < 5 and boardArray[y + 1][x + 1] == "w":
+                return [x, y, x + 1, y + 2, 5]
+            if boardArray[y + 1][x] == " ":
+                return [x, y, x, y + 1, 3]
+        if x == 2 or x == 3:
+            if boardArray[y + 1][x + 1] == "w":
+                return [x, y, x + 1, y + 1, 6]
+            if boardArray[y + 1][x - 1] == "w":
+                return [x, y, x - 1, y + 1, 6]
+            if boardArray[y + 1][x] == " ":
+                return [x, y, x, y + 1, 4]
+    if y == 0:
+        if x < 2 or x > 3:
+            if boardArray[y + 2][x] == " ":
+                return [x, y, x, y + 2, 3]
+            if boardArray[y + 1][x] == " ":
+                return [x, y, x, y + 1, 1]
+        if x == 2 or x == 3:
+            if boardArray[y + 2][x] == " ":
+                return [x, y, x, y + 2, 4]
+            if boardArray[y + 1][x] == " ":
+                return [x, y, x, y + 1, 2]
+    if y < 2:
+        if x < 2 or x > 3:
+            if x > 0 and boardArray[y + 1][x - 1] == "w":
+                return [x, y, x - 1, y + 1, 4]
+            if x < 5 and boardArray[y + 1][x + 1] == "w":
+                return [x, y, x + 1, y + 2, 4]
+            if boardArray[y + 1][x] == " ":
+                return [x, y, x, y + 1, 1]
+        if x == 2 or x == 3:
+            if boardArray[y + 1][x + 1] == "w":
+                return [x, y, x + 1, y + 1, 5]
+            if boardArray[y + 1][x - 1] == "w":
+                return [x, y, x - 1, y + 1, 5]
+            if boardArray[y + 1][x] == " ":
+                return [x, y, x, y + 1, 2]
+    return [0, 0, 0, 0, 0]
+
+
+
 
-def chessGame(sizeX,sizeY,screen, userName, difficulty):
-    global selected_pawn, beaten_pawn, pawn_to_beat, last_pos
+def chessGame(sizeX, sizeY, screen, userName, difficulty):
+
+    global selected_pawn, beaten_pawn, pawn_to_beat
+
+    clock = pygame.time.Clock()
+    UI_REFRESH_RATE = clock.tick(60)/1000
+
     current_turn = "white"
     run = True
     last_pos = None
-    unique_ID = f"{uuid.uuid4()}"
-    print(type(unique_ID))
-  
+    zuege = 0
+    gewonnen = False
+    pawn_to_beat = None
+
+
+
+    manager = pygame_gui.UIManager((sizeX, sizeY))
+
     screen.fill("black")
-    global selected_pawn
     screen.blit(board, ((sizeX/2)-(480/2), (sizeY/2)-(480/2)))
-    
+    pygame.display.flip()
 
-    backgroundIMG = pygame.image.load("resources/envi.jpg")
-    background = pygame.transform.scale(backgroundIMG,(sizeX, sizeY))
-
-    screen.blit(background, (0, 0))
-
-    reRender(sizeX, sizeY, screen)
+    helpButton = pygame_gui.elements.UIButton(relative_rect=pygame.Rect(((sizeX/1.2)-20, sizeY/1.12), (sizeX/6, 50)), text = "BACK",  manager=manager,
+                                            object_id='#helpButton')
 
     # the game
     while run is True:
-        
-        MENU_MOUSE_POS = pygame.mouse.get_pos()
-        showHelp = Button(image=pygame.image.load("resources/test.png"), pos=(sizeX-100, sizeY-50), 
-                            text_input="Regeln", font=font(30), base_color="#d7fcd4", hovering_color="Yellow")
-        
-        for button in [showHelp]:
-            button.changeColor(MENU_MOUSE_POS)
-            button.update(screen)
-            reRender(sizeX, sizeY, screen)
-
-        for event in pygame.event.get():
-            if event.type == pygame.QUIT:
-                pygame.quit()
-                sys.exit()
-            if event.type == pygame.MOUSEBUTTONDOWN:
-                if showHelp.checkForInput(MENU_MOUSE_POS):
-                    
-                    messagebox.showinfo("""
-                    Es gibt zwei erlaubte Sorten von Zügen :
-                    1)	Ziehen
-                    kann ein Bauer, indem er ein Feld in Richtung der gegnerischen Grundlinie (das sind die Felder, auf denen anfangs die gegnerischen Bauern stehen) geht, aber nur sofern dieses Feld frei ist (also nicht von einem eigenen oder gegnerischen Bauern besetzt ist). 
-                    2)	Schlagen
-                    kann ein Bauer in Richtung der gegnerischen Grundlinie durch diagonales Ziehen in Richtung der gegnerischen Grundlinie, aber nur auf ein Feld, auf dem ein gegnerischer Bauer steht. 
-                    """, """Bauernschach
-                    ist eine simple Variante des Schachs, die nur mit Bauern gespielt wird. In der Ausgansstellung stehen dabei die weißen bzw. schwarzen Spielfiguren (Bauern) auf der jeweiligen Grundlinie. Die Spieler machen abwechselnd einen Zug, wobei Weiß beginnt. 
+        if gewonnen is False:
+            if current_turn == "white":
+                for event in pygame.event.get():
+                    if event.type == pygame.QUIT:
+                        pygame.quit()
+                        sys.exit()
 
-                    Für den Prototypen soll immer der menschliche Spieler beginnen und die KI entsprechend mit den schwarzen Spielfiguren ziehen. 
+                    if(event.type == pygame_gui.UI_BUTTON_PRESSED and event.ui_object_id == '#helpButton'):
+                        print("hi")
 
-                    Es gibt zwei erlaubte Sorten von Zügen :
-                    1)	Ziehen
-                    kann ein Bauer, indem er ein Feld in Richtung der gegnerischen Grundlinie (das sind die Felder, auf denen anfangs die gegnerischen Bauern stehen) geht, aber nur sofern dieses Feld frei ist (also nicht von einem eigenen oder gegnerischen Bauern besetzt ist). 
-                    2)	Schlagen
-                    kann ein Bauer in Richtung der gegnerischen Grundlinie durch diagonales Ziehen in Richtung der gegnerischen Grundlinie, aber nur auf ein Feld, auf dem ein gegnerischer Bauer steht. 
-
-                    Ziel des Spieles ist es, einen Bauern auf die generische Grundlinie zu platzieren; wenn das gelingt, ist das Spiel sofort zu Ende und die Farbe, die das erreicht hat, hat gewonnen. Wenn ein Spieler nicht mehr ziehen kann, oder überhaupt keine Figuren mehr hat, ist das Spiel für ihn als verloren zu werten. Ein unentschieden ist daher in dieser Variante nicht möglich.
-                    """)
-                
-            if event.type == pygame.MOUSEBUTTONDOWN:
-                # Speichert die Position des Mouseklicks in der Variable pos
-                pos = pygame.mouse.get_pos()
+                    if event.type == pygame.MOUSEBUTTONDOWN:
+                        # Speichert die Position des Mouseklicks in der Variable pos
+                        pos = pygame.mouse.get_pos()
 
-                # Konvertiert die Positionen in Boardkoordinaten
-                x = (pos[0] - (int)((sizeX/2)-(480/2))) // 80
-                y = (pos[1] - (int)((sizeY/2)-(480/2))) // 80
+                        # Konvertiert die Positionen in Boardkoordinaten
+                        x = (pos[0] - (int)((sizeX/2)-(480/2))) // 80
+                        y = (pos[1] - (int)((sizeY/2)-(480/2))) // 80
 
-                if selected_pawn is None or (selected_pawn is not None and selected_pawn.color is not current_turn):
-                    # Prüft, ob ein Bauer angeklickt wurde
-                    for pawn in pawns:
-                        if pawn.x == x and pawn.y == y:
-                            selected_pawn = pawn
-
-                            print(pawn)
-                            break
-
 
-                    # Prüft, ob ein Bauer angeklickt wurde
-                    for pawn in pawns:
-                        if pawn.x == x and pawn.y == y:
-                            selected_pawn = pawn
+                        # Prüft, ob ein Bauer angeklickt wurde
+                        for pawn in pawns:
+                            if pawn.x == x and pawn.y == y:
+                                selected_pawn = pawn
 
-                            print(pawn)
-                            break
-                    last_pos = pos
-            elif event.type == pygame.MOUSEBUTTONUP and selected_pawn is not None and selected_pawn.color is \
-                    current_turn:
-                # Speichert die Position des Mouseklicks
-                pos = pygame.mouse.get_pos()
+                                print(pawn)
+                                break
+
+                    elif event.type == pygame.MOUSEBUTTONUP and selected_pawn is not None and selected_pawn.color is \
+                            current_turn:
+                        # Speichert die Position des Mouseklicks
+                        pos = pygame.mouse.get_pos()
 
-                # Konvertiert die Positionen in Boardkoordinaten
-                x = (pos[0] - (int)((sizeX/2)-(480/2))) // 80
-                y = (pos[1] - (int)((sizeY/2)-(480/2))) // 80
+                        # Konvertiert die Positionen in Boardkoordinaten
+                        x = (pos[0] - (int)((sizeX/2)-(480/2))) // 80
+                        y = (pos[1] - (int)((sizeY/2)-(480/2))) // 80
 
-                for pawn in pawns:
-                    beaten_pawn = False
-                    if pawn.x == x and pawn.y == y and pawn.color is not selected_pawn.color:
-                        pawn_to_beat = pawn
-                        beaten_pawn = True
-                        break
+                        for pawn in pawns:
+                            beaten_pawn = False
+                            if pawn.x == x and pawn.y == y and pawn.color is not selected_pawn.color:
+                                pawn_to_beat = pawn
+                                beaten_pawn = True
+                                break
 
-                # Spielfigur bewegen, wenn der Spielzug gültig ist
-                if selected_pawn.color == "white" and selected_pawn.color == current_turn:
-                    if selected_pawn.y == 5 and y == 3 and x == selected_pawn.x and beaten_pawn is False:
-                        # Möglichkeit beim ersten Spielzug zwei Felder zu bewegen
-                        selected_pawn.x = x
-                        selected_pawn.y = y
-                        current_turn = "black"
-                    elif y == selected_pawn.y - 1 and x == selected_pawn.x and beaten_pawn is False:
-                        # Ein Spielfeld nach vorne bewegen
-                        selected_pawn.x = x
-                        selected_pawn.y = y
-                        current_turn = "black"
-                    elif y == selected_pawn.y - 1 and x == selected_pawn.x - 1 and beaten_pawn is True:
-                        selected_pawn.x = x
-                        selected_pawn.y = y
-                        current_turn = "black"
-                        pawns.remove(pawn_to_beat)
-                    elif y == selected_pawn.y - 1 and x == selected_pawn.x + 1 and beaten_pawn is True:
-                        selected_pawn.x = x
-                        selected_pawn.y = y
-                        current_turn = "black"
-                        pawns.remove(pawn_to_beat)
-                elif selected_pawn.color == "black" and selected_pawn.color == current_turn:
-                    if selected_pawn.y == 0 and y == 2 and x == selected_pawn.x and beaten_pawn is False:
+                        # Spielfigur bewegen, wenn der Spielzug gültig ist
+                        if selected_pawn.color == "white" and selected_pawn.color == current_turn:
+                            if selected_pawn.y == 5 and y == 3 and x == selected_pawn.x and beaten_pawn is False:
+                                # Möglichkeit beim ersten Spielzug zwei Felder zu bewegen
+                                boardArray[selected_pawn.y][selected_pawn.x] = " "
+                                boardArray[y][x] = "w"
+                                selected_pawn.x = x
+                                selected_pawn.y = y
+                                current_turn = "black"
+                                zuege += 1
+                            elif y == selected_pawn.y - 1 and x == selected_pawn.x and beaten_pawn is False:
+                                # Ein Spielfeld nach vorne bewegen
+                                boardArray[selected_pawn.y][selected_pawn.x] = "w"
+                                boardArray[y][x] = " "
+                                selected_pawn.x = x
+                                selected_pawn.y = y
+                                current_turn = "black"
+                                zuege += 1
+                            elif y == selected_pawn.y - 1 and x == selected_pawn.x - 1 and beaten_pawn is True:
+                                boardArray[selected_pawn.y][selected_pawn.x] = " "
+                                boardArray[y][x] = "w"
+                                selected_pawn.x = x
+                                selected_pawn.y = y
+                                current_turn = "black"
+                                pawns.remove(pawn_to_beat)
+                                zuege += 1
+                            elif y == selected_pawn.y - 1 and x == selected_pawn.x + 1 and beaten_pawn is True:
+                                boardArray[selected_pawn.y][selected_pawn.x] = " "
+                                boardArray[y][x] = "w"
+                                selected_pawn.x = x
+                                selected_pawn.y = y
+                                current_turn = "black"
+                                pawns.remove(pawn_to_beat)
+                                zuege += 1
+                        if selected_pawn.color == "white" and selected_pawn.y == 0:
+                            gewonnen = True
+                            print("Weiß hat gewonnen")
+
+                        reRender(sizeX, sizeY, screen)
+
+                        manager.process_events(event)
+                    manager.update(UI_REFRESH_RATE)
+            elif current_turn == "black":
+                board_copy = boardArray
+                best_move = [0, 0, 0, 0, 0]
+
+                x = 0
+
+                while x < 6:
+                    y = 0
+                    while y < 6:
+                        if board_copy[y][x] == "b":
+                            current_move = getBestMove(x, y, board_copy)
+                            if best_move[4] <= current_move[4]:
+                                best_move = current_move
+                        y += 1
+                    x += 1
+
+                x_move = best_move[0]
+                y_move = best_move[1]
+
+                x_destination = best_move[2]
+                y_destination = best_move[3]
+
+                print(f"Bester Zug: Von {x_move}, "
+                      f"{y_move} nach {x_destination}, {y_destination} mit der Value {best_move[4]}")
+
+                for pawn in pawns:
+                    if pawn.x == x_move and pawn.y == y_move:
+                        selected_pawn = pawn
+                        break
+
+                for pawn in pawns:
+                    beaten_pawn = False
+                    if pawn.x == x_destination and pawn.y == y_destination and pawn.color != selected_pawn.color:
+                        pawn_to_beat = pawn
+                        beaten_pawn = True
+                        break
+
+                if selected_pawn.color == "black" and selected_pawn.color == current_turn:
+                    if y_move == 0 and y_destination == 2 and x_destination == x_move and \
+                            beaten_pawn is False:
                         # Möglichkeit beim ersten Spielzug zwei Felder zu bewegen
-                        selected_pawn.x = x
-                        selected_pawn.y = y
-                        current_turn = "white"
-                    elif y == selected_pawn.y + 1 and x == selected_pawn.x and beaten_pawn is False:
+                        boardArray[selected_pawn.y][selected_pawn.x] = " "
+                        boardArray[y_destination][x_destination] = "b"
+                        selected_pawn.x = x_destination
+                        selected_pawn.y = y_destination
+                    elif y_destination == y_move - 1 and x_destination == x_move and beaten_pawn is False:
                         # Ein Spielfeld nach vorne bewegen
-                        selected_pawn.x = x
-                        selected_pawn.y = y
-                        current_turn = "white"
-                    elif y == selected_pawn.y + 1 and x == selected_pawn.x - 1 and beaten_pawn is True:
-                        selected_pawn.x = x
-                        selected_pawn.y = y
-                        current_turn = "white"
+                        boardArray[selected_pawn.y][selected_pawn.x] = " "
+                        boardArray[y_destination][x_destination] = "b"
+                        selected_pawn.x = x_destination
+                        selected_pawn.y = y_destination
+                    elif y_destination == y_move - 1 and x_destination == x_move - 1 and \
+                            beaten_pawn is True:
+                        boardArray[selected_pawn.y][selected_pawn.x] = " "
+                        boardArray[y_destination][x_destination] = "b"
+                        selected_pawn.x = x_destination
+                        selected_pawn.y = y_destination
                         pawns.remove(pawn_to_beat)
-                    elif y == selected_pawn.y + 1 and x == selected_pawn.x + 1 and beaten_pawn is True:
-                        selected_pawn.x = x
-                        selected_pawn.y = y
-                        current_turn = "white"
+                    elif y_destination == x_move - 1 and x_destination == x_move + 1 and \
+                            beaten_pawn is True:
+                        boardArray[selected_pawn.y][selected_pawn.x] = " "
+                        boardArray[y_destination][x_destination] = "b"
+                        selected_pawn.x = x_destination
+                        selected_pawn.y = y_destination
                         pawns.remove(pawn_to_beat)
-                if selected_pawn.color == "white" and selected_pawn.y == 0:
-                    run = False
-                    print("Weiß hat gewonnen")
-                    print(f"{unique_ID}, {userName}, turns, {difficulty}, {0}")
-                    postFinishedGameQuery(unique_ID, userName, 15, 2, False)
-                    
-
-                elif selected_pawn.color == "black" and selected_pawn.y == 5:
-                    run = False
+                if selected_pawn.color == "black" and selected_pawn.y == 0:
+                    gewonnen = True
                     print("Schwarz hat gewonnen")
-                    print(f"{unique_ID}, {userName}, turns, {difficulty}, {1}")
-                    postFinishedGameQuery(unique_ID, userName, 11, 2, True)
 
-                reRender(sizeX, sizeY, screen)
-
+                current_turn = "white"
+                print(boardArray)
+                reRender(sizeX, sizeY, screen)
\ No newline at end of file
Index: .idea/workspace.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+><?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<project version=\"4\">\r\n  <component name=\"ChangeListManager\">\r\n    <list default=\"true\" id=\"f2baf0e4-a2ae-4c29-8316-e85e5ad6a870\" name=\"Changes\" comment=\"rechtschreibkorrektur\">\r\n      <change beforePath=\"$PROJECT_DIR$/.idea/workspace.xml\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/.idea/workspace.xml\" afterDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/DB/__init__.py\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/DB/__init__.py\" afterDir=\"false\" />\r\n    </list>\r\n    <option name=\"SHOW_DIALOG\" value=\"false\" />\r\n    <option name=\"HIGHLIGHT_CONFLICTS\" value=\"true\" />\r\n    <option name=\"HIGHLIGHT_NON_ACTIVE_CHANGELIST\" value=\"false\" />\r\n    <option name=\"LAST_RESOLUTION\" value=\"IGNORE\" />\r\n  </component>\r\n  <component name=\"FileTemplateManagerImpl\">\r\n    <option name=\"RECENT_TEMPLATES\">\r\n      <list>\r\n        <option value=\"Python Script\" />\r\n      </list>\r\n    </option>\r\n  </component>\r\n  <component name=\"Git.Settings\">\r\n    <option name=\"RECENT_BRANCH_BY_REPOSITORY\">\r\n      <map>\r\n        <entry key=\"$PROJECT_DIR$\" value=\"master\" />\r\n      </map>\r\n    </option>\r\n    <option name=\"RECENT_GIT_ROOT_PATH\" value=\"$PROJECT_DIR$\" />\r\n  </component>\r\n  <component name=\"MarkdownSettingsMigration\">\r\n    <option name=\"stateVersion\" value=\"1\" />\r\n  </component>\r\n  <component name=\"ProjectId\" id=\"2NSWYP72UQRzYksz8mSWK3a8qip\" />\r\n  <component name=\"ProjectViewState\">\r\n    <option name=\"hideEmptyMiddlePackages\" value=\"true\" />\r\n    <option name=\"showLibraryContents\" value=\"true\" />\r\n  </component>\r\n  <component name=\"PropertiesComponent\">{\r\n  &quot;keyToString&quot;: {\r\n    &quot;RunOnceActivity.OpenProjectViewOnStart&quot;: &quot;true&quot;,\r\n    &quot;RunOnceActivity.ShowReadmeOnStart&quot;: &quot;true&quot;,\r\n    &quot;last_opened_file_path&quot;: &quot;C:/Users/recin/Documents/GitHub/devshhbk&quot;,\r\n    &quot;settings.editor.selected.configurable&quot;: &quot;com.jetbrains.python.configuration.PyActiveSdkModuleConfigurable&quot;\r\n  }\r\n}</component>\r\n  <component name=\"RecentsManager\">\r\n    <key name=\"MoveFile.RECENT_KEYS\">\r\n      <recent name=\"C:\\Users\\recin\\Documents\\GitHub\\devshhbk\\Backend\" />\r\n    </key>\r\n  </component>\r\n  <component name=\"RunManager\" selected=\"Python.__init__\">\r\n    <configuration name=\"Tic_Tac_Toe_Spiel\" type=\"PythonConfigurationType\" factoryName=\"Python\" temporary=\"true\" nameIsGenerated=\"true\">\r\n      <module name=\"devshhbk\" />\r\n      <option name=\"INTERPRETER_OPTIONS\" value=\"\" />\r\n      <option name=\"PARENT_ENVS\" value=\"true\" />\r\n      <envs>\r\n        <env name=\"PYTHONUNBUFFERED\" value=\"1\" />\r\n      </envs>\r\n      <option name=\"SDK_HOME\" value=\"\" />\r\n      <option name=\"WORKING_DIRECTORY\" value=\"$PROJECT_DIR$/Backend\" />\r\n      <option name=\"IS_MODULE_SDK\" value=\"true\" />\r\n      <option name=\"ADD_CONTENT_ROOTS\" value=\"true\" />\r\n      <option name=\"ADD_SOURCE_ROOTS\" value=\"true\" />\r\n      <option name=\"SCRIPT_NAME\" value=\"$PROJECT_DIR$/Backend/Tic_Tac_Toe_Spiel.py\" />\r\n      <option name=\"PARAMETERS\" value=\"\" />\r\n      <option name=\"SHOW_COMMAND_LINE\" value=\"false\" />\r\n      <option name=\"EMULATE_TERMINAL\" value=\"false\" />\r\n      <option name=\"MODULE_MODE\" value=\"false\" />\r\n      <option name=\"REDIRECT_INPUT\" value=\"false\" />\r\n      <option name=\"INPUT_FILE\" value=\"\" />\r\n      <method v=\"2\" />\r\n    </configuration>\r\n    <configuration name=\"__init__\" type=\"PythonConfigurationType\" factoryName=\"Python\" temporary=\"true\" nameIsGenerated=\"true\">\r\n      <module name=\"devshhbk\" />\r\n      <option name=\"INTERPRETER_OPTIONS\" value=\"\" />\r\n      <option name=\"PARENT_ENVS\" value=\"true\" />\r\n      <envs>\r\n        <env name=\"PYTHONUNBUFFERED\" value=\"1\" />\r\n      </envs>\r\n      <option name=\"SDK_HOME\" value=\"\" />\r\n      <option name=\"WORKING_DIRECTORY\" value=\"$PROJECT_DIR$/DB\" />\r\n      <option name=\"IS_MODULE_SDK\" value=\"true\" />\r\n      <option name=\"ADD_CONTENT_ROOTS\" value=\"true\" />\r\n      <option name=\"ADD_SOURCE_ROOTS\" value=\"true\" />\r\n      <option name=\"SCRIPT_NAME\" value=\"$PROJECT_DIR$/DB/__init__.py\" />\r\n      <option name=\"PARAMETERS\" value=\"\" />\r\n      <option name=\"SHOW_COMMAND_LINE\" value=\"false\" />\r\n      <option name=\"EMULATE_TERMINAL\" value=\"false\" />\r\n      <option name=\"MODULE_MODE\" value=\"false\" />\r\n      <option name=\"REDIRECT_INPUT\" value=\"false\" />\r\n      <option name=\"INPUT_FILE\" value=\"\" />\r\n      <method v=\"2\" />\r\n    </configuration>\r\n    <configuration name=\"main\" type=\"PythonConfigurationType\" factoryName=\"Python\" nameIsGenerated=\"true\">\r\n      <module name=\"devshhbk\" />\r\n      <option name=\"INTERPRETER_OPTIONS\" value=\"\" />\r\n      <option name=\"PARENT_ENVS\" value=\"true\" />\r\n      <envs>\r\n        <env name=\"PYTHONUNBUFFERED\" value=\"1\" />\r\n      </envs>\r\n      <option name=\"SDK_HOME\" value=\"\" />\r\n      <option name=\"WORKING_DIRECTORY\" value=\"$PROJECT_DIR$\" />\r\n      <option name=\"IS_MODULE_SDK\" value=\"true\" />\r\n      <option name=\"ADD_CONTENT_ROOTS\" value=\"true\" />\r\n      <option name=\"ADD_SOURCE_ROOTS\" value=\"true\" />\r\n      <option name=\"SCRIPT_NAME\" value=\"$PROJECT_DIR$/main.py\" />\r\n      <option name=\"PARAMETERS\" value=\"\" />\r\n      <option name=\"SHOW_COMMAND_LINE\" value=\"false\" />\r\n      <option name=\"EMULATE_TERMINAL\" value=\"false\" />\r\n      <option name=\"MODULE_MODE\" value=\"false\" />\r\n      <option name=\"REDIRECT_INPUT\" value=\"false\" />\r\n      <option name=\"INPUT_FILE\" value=\"\" />\r\n      <method v=\"2\" />\r\n    </configuration>\r\n    <recent_temporary>\r\n      <list>\r\n        <item itemvalue=\"Python.__init__\" />\r\n        <item itemvalue=\"Python.Tic_Tac_Toe_Spiel\" />\r\n        <item itemvalue=\"Python.Tic_Tac_Toe_Spiel\" />\r\n      </list>\r\n    </recent_temporary>\r\n  </component>\r\n  <component name=\"SpellCheckerSettings\" RuntimeDictionaries=\"0\" Folders=\"0\" CustomDictionaries=\"0\" DefaultDictionary=\"application-level\" UseSingleDictionary=\"true\" transferred=\"true\" />\r\n  <component name=\"TaskManager\">\r\n    <task active=\"true\" id=\"Default\" summary=\"Default task\">\r\n      <changelist id=\"f2baf0e4-a2ae-4c29-8316-e85e5ad6a870\" name=\"Changes\" comment=\"\" />\r\n      <created>1679658011105</created>\r\n      <option name=\"number\" value=\"Default\" />\r\n      <option name=\"presentableId\" value=\"Default\" />\r\n      <updated>1679658011105</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00001\" summary=\"keine ahnung\">\r\n      <created>1680169680304</created>\r\n      <option name=\"number\" value=\"00001\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00001\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1680169680304</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00002\" summary=\"verschiebung code bauernschach\">\r\n      <created>1680169719176</created>\r\n      <option name=\"number\" value=\"00002\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00002\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1680169719176</updated>\r\n    </task>\r\n    <option name=\"localTasksCounter\" value=\"3\" />\r\n    <servers />\r\n  </component>\r\n  <component name=\"Vcs.Log.Tabs.Properties\">\r\n    <option name=\"TAB_STATES\">\r\n      <map>\r\n        <entry key=\"MAIN\">\r\n          <value>\r\n            <State />\r\n          </value>\r\n        </entry>\r\n      </map>\r\n    </option>\r\n  </component>\r\n  <component name=\"VcsManagerConfiguration\">\r\n    <MESSAGE value=\"keine ahnung\" />\r\n    <MESSAGE value=\"verschiebung code bauernschach\" />\r\n    <option name=\"LAST_COMMIT_MESSAGE\" value=\"verschiebung code bauernschach\" />\r\n  </component>\r\n</project>
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/.idea/workspace.xml b/.idea/workspace.xml
--- a/.idea/workspace.xml	(revision 46b76cb67b45b818d6408c1a503c2d227b91239d)
+++ b/.idea/workspace.xml	(date 1681916911853)
@@ -2,8 +2,16 @@
 <project version="4">
   <component name="ChangeListManager">
     <list default="true" id="f2baf0e4-a2ae-4c29-8316-e85e5ad6a870" name="Changes" comment="rechtschreibkorrektur">
+      <change beforePath="$PROJECT_DIR$/.idea/shelf/Uncommitted_changes_before_Checkout_at_18_04_2023_12_08__Changes_.xml" beforeDir="false" afterPath="$PROJECT_DIR$/.idea/shelf/Uncommitted_changes_before_Checkout_at_18_04_2023_12_08__Changes_.xml" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/.idea/shelf/Uncommitted_changes_before_Checkout_at_18_04_2023_12_08__Changes_1.xml" beforeDir="false" afterPath="$PROJECT_DIR$/.idea/shelf/Uncommitted_changes_before_Checkout_at_18_04_2023_12_08__Changes_1.xml" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/.idea/shelf/Uncommitted_changes_before_Checkout_at_18_04_2023_12_10__Changes_.xml" beforeDir="false" afterPath="$PROJECT_DIR$/.idea/shelf/Uncommitted_changes_before_Checkout_at_18_04_2023_12_10__Changes_.xml" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/.idea/shelf/Uncommitted_changes_before_Merge_at_18_04_2023_12_09__Changes_.xml" beforeDir="false" afterPath="$PROJECT_DIR$/.idea/shelf/Uncommitted_changes_before_Merge_at_18_04_2023_12_09__Changes_.xml" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/.idea/shelf/Uncommitted_changes_before_Update_at_18_04_2023_12_10__Changes_.xml" beforeDir="false" afterPath="$PROJECT_DIR$/.idea/shelf/Uncommitted_changes_before_Update_at_18_04_2023_12_10__Changes_.xml" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/.idea/shelf/Uncommitted_changes_before_Update_at_19_04_2023_10_03__Changes_.xml" beforeDir="false" afterPath="$PROJECT_DIR$/.idea/shelf/Uncommitted_changes_before_Update_at_19_04_2023_10_03__Changes_.xml" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/.idea/shelf/Uncommitted_changes_before_Update_at_19_04_2023_10_11__Changes_.xml" beforeDir="false" afterPath="$PROJECT_DIR$/.idea/shelf/Uncommitted_changes_before_Update_at_19_04_2023_10_11__Changes_.xml" afterDir="false" />
       <change beforePath="$PROJECT_DIR$/.idea/workspace.xml" beforeDir="false" afterPath="$PROJECT_DIR$/.idea/workspace.xml" afterDir="false" />
-      <change beforePath="$PROJECT_DIR$/DB/__init__.py" beforeDir="false" afterPath="$PROJECT_DIR$/DB/__init__.py" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/Backend/Bauernschach_Spiel.py" beforeDir="false" afterPath="$PROJECT_DIR$/Backend/Bauernschach_Spiel.py" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/DB/StrategiespieleDB.db" beforeDir="false" afterPath="$PROJECT_DIR$/DB/StrategiespieleDB.db" afterDir="false" />
     </list>
     <option name="SHOW_DIALOG" value="false" />
     <option name="HIGHLIGHT_CONFLICTS" value="true" />
@@ -20,7 +28,7 @@
   <component name="Git.Settings">
     <option name="RECENT_BRANCH_BY_REPOSITORY">
       <map>
-        <entry key="$PROJECT_DIR$" value="master" />
+        <entry key="$PROJECT_DIR$" value="dv" />
       </map>
     </option>
     <option name="RECENT_GIT_ROOT_PATH" value="$PROJECT_DIR$" />
@@ -46,7 +54,28 @@
       <recent name="C:\Users\recin\Documents\GitHub\devshhbk\Backend" />
     </key>
   </component>
-  <component name="RunManager" selected="Python.__init__">
+  <component name="RunManager" selected="Python.Game">
+    <configuration name="Game" type="PythonConfigurationType" factoryName="Python" temporary="true" nameIsGenerated="true">
+      <module name="devshhbk" />
+      <option name="INTERPRETER_OPTIONS" value="" />
+      <option name="PARENT_ENVS" value="true" />
+      <envs>
+        <env name="PYTHONUNBUFFERED" value="1" />
+      </envs>
+      <option name="SDK_HOME" value="" />
+      <option name="WORKING_DIRECTORY" value="$PROJECT_DIR$/Backend" />
+      <option name="IS_MODULE_SDK" value="true" />
+      <option name="ADD_CONTENT_ROOTS" value="true" />
+      <option name="ADD_SOURCE_ROOTS" value="true" />
+      <option name="SCRIPT_NAME" value="$PROJECT_DIR$/Backend/Game.py" />
+      <option name="PARAMETERS" value="" />
+      <option name="SHOW_COMMAND_LINE" value="false" />
+      <option name="EMULATE_TERMINAL" value="false" />
+      <option name="MODULE_MODE" value="false" />
+      <option name="REDIRECT_INPUT" value="false" />
+      <option name="INPUT_FILE" value="" />
+      <method v="2" />
+    </configuration>
     <configuration name="Tic_Tac_Toe_Spiel" type="PythonConfigurationType" factoryName="Python" temporary="true" nameIsGenerated="true">
       <module name="devshhbk" />
       <option name="INTERPRETER_OPTIONS" value="" />
@@ -112,6 +141,7 @@
     </configuration>
     <recent_temporary>
       <list>
+        <item itemvalue="Python.Game" />
         <item itemvalue="Python.__init__" />
         <item itemvalue="Python.Tic_Tac_Toe_Spiel" />
         <item itemvalue="Python.Tic_Tac_Toe_Spiel" />
@@ -160,4 +190,15 @@
     <MESSAGE value="verschiebung code bauernschach" />
     <option name="LAST_COMMIT_MESSAGE" value="verschiebung code bauernschach" />
   </component>
+  <component name="XDebuggerManager">
+    <breakpoint-manager>
+      <breakpoints>
+        <line-breakpoint enabled="true" suspend="THREAD" type="python-line">
+          <url>file://$PROJECT_DIR$/Backend/Bauernschach_Spiel.py</url>
+          <line>296</line>
+          <option name="timeStamp" value="16" />
+        </line-breakpoint>
+      </breakpoints>
+    </breakpoint-manager>
+  </component>
 </project>
\ No newline at end of file
